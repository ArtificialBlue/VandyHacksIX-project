{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.areBoundsEqual = mod.exports;\n  }\n})(this, function (exports) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  /**\n   * Compares two bound objects.\n   */\n\n  var areBoundsEqual = exports.areBoundsEqual = function areBoundsEqual(boundA, boundB) {\n    if (boundA === boundB) {\n      return true;\n    }\n    if (!(boundA instanceof Object) || !(boundB instanceof Object)) {\n      return false;\n    }\n    if (Object.keys(boundA).length !== Object.keys(boundB).length) {\n      return false;\n    }\n    if (!areValidBounds(boundA) || !areValidBounds(boundB)) {\n      return false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (var _iterator = Object.keys(boundA)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n        if (boundA[key] !== boundB[key]) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Helper that checks whether an array consists of objects\n   * with lat and lng properties\n   * @param {object} elem the element to check\n   * @returns {boolean} whether or not it's valid\n   */\n  var areValidBounds = function areValidBounds(elem) {\n    return elem !== null && (typeof elem === 'undefined' ? 'undefined' : _typeof(elem)) === 'object' && elem.hasOwnProperty('north') && elem.hasOwnProperty('south') && elem.hasOwnProperty('east') && elem.hasOwnProperty('west');\n  };\n});","map":{"version":3,"names":["global","factory","define","amd","exports","mod","areBoundsEqual","Object","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","prototype","boundA","boundB","keys","length","areValidBounds","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","key","err","return","elem","hasOwnProperty"],"sources":["C:/Users/georg/Documents/GitHub/VandyHacksIX-project/vessel-tracker/node_modules/google-maps-react/dist/lib/areBoundsEqual.js"],"sourcesContent":["(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports);\n    global.areBoundsEqual = mod.exports;\n  }\n})(this, function (exports) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  /**\n   * Compares two bound objects.\n   */\n\n  var areBoundsEqual = exports.areBoundsEqual = function areBoundsEqual(boundA, boundB) {\n    if (boundA === boundB) {\n      return true;\n    }\n    if (!(boundA instanceof Object) || !(boundB instanceof Object)) {\n      return false;\n    }\n    if (Object.keys(boundA).length !== Object.keys(boundB).length) {\n      return false;\n    }\n    if (!areValidBounds(boundA) || !areValidBounds(boundB)) {\n      return false;\n    }\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.keys(boundA)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n\n        if (boundA[key] !== boundB[key]) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Helper that checks whether an array consists of objects\n   * with lat and lng properties\n   * @param {object} elem the element to check\n   * @returns {boolean} whether or not it's valid\n   */\n  var areValidBounds = function areValidBounds(elem) {\n    return elem !== null && (typeof elem === 'undefined' ? 'undefined' : _typeof(elem)) === 'object' && elem.hasOwnProperty('north') && elem.hasOwnProperty('south') && elem.hasOwnProperty('east') && elem.hasOwnProperty('west');\n  };\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}